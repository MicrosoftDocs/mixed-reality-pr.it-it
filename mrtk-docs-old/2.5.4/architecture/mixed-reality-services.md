---
title: MixedRealityServices
description: Servizi correlati a MRTK in Unity.
author: davidkline-ms
ms.author: davidkl
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, realtà mista, sviluppo, MRTK,
ms.openlocfilehash: c23c16e7dac54ff209beca24bd8b8b857967f697
ms.sourcegitcommit: 59c91f8c70d1ad30995fba6cf862615e25e78d10
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/19/2021
ms.locfileid: "104690371"
---
# <a name="what-makes-a-mixed-reality-feature"></a><span data-ttu-id="fd3ea-104">Cosa rende una funzionalità di realtà mista</span><span class="sxs-lookup"><span data-stu-id="fd3ea-104">What makes a mixed reality feature</span></span>

<span data-ttu-id="fd3ea-105">Per evitare sovraccarichi delle prestazioni della `MonoBehaviour` classe, tutti i *Servizi* (sistemi, funzionalità o moduli che richiedono operazioni indipendenti in una soluzione di realtà mista, ad esempio input, limite, conoscenza spaziale), devono essere semplici classi c# discrete che implementano `IMixedRealityService` e per la registrazione in `MixedRealityToolkit` .</span><span class="sxs-lookup"><span data-stu-id="fd3ea-105">To avoid the performance overheads of the `MonoBehaviour` class, all *services* (systems, features, or modules that require independent operation in a mixed reality solution, e.g. input, boundary, spatial awareness) are required to be discrete plain old c# classes which implement `IMixedRealityService` and to register with the `MixedRealityToolkit`.</span></span>

<span data-ttu-id="fd3ea-106">`MixedRealityToolkit`Quindi coordina tutti i riferimenti tra i servizi e garantisce che ricevano tutti gli eventi appropriati, ad esempio</span><span class="sxs-lookup"><span data-stu-id="fd3ea-106">The `MixedRealityToolkit` then coordinates all referencing between services and ensures that they receive all appropriate events (E.g.</span></span> <span data-ttu-id="fd3ea-107">È possibile riattivare/inizializzare, aggiornare, eliminare definitivamente e facilitare la ricerca di altri servizi, quando necessario.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-107">Awake/Initialize, Update, Destroy) as well as facilitating the finding of other services when needed.</span></span>

<span data-ttu-id="fd3ea-108">Inoltre, `MixedRealityToolkit` gestisce anche l'SDK attivo VR/XR/AR in uso nel progetto in esecuzione, per inizializzare il dispositivo attivo in base all'hardware collegato e istigare il corretto funzionamento.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-108">Additionally, the `MixedRealityToolkit` also maintains the active VR/XR/AR SDK in use in the running project, to initialize the active device based on attached hardware and instigate proper operation.</span></span>

## <a name="a-service"></a><span data-ttu-id="fd3ea-109">Un servizio</span><span class="sxs-lookup"><span data-stu-id="fd3ea-109">A service</span></span>

<span data-ttu-id="fd3ea-110">Un singolo servizio può essere qualsiasi funzionalità che deve essere implementata nel progetto.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-110">An individual service can be any functionality that needs to be implemented in the project.</span></span> <span data-ttu-id="fd3ea-111">Tradizionalmente alcuni progetti usano i *singleton* che devono essere attivi nella scena, ma questo modello presenta vantaggi e svantaggi.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-111">Traditionally some projects use *singletons* which need to be alive in the scene, but this pattern has its advantages and disadvantages.</span></span> <span data-ttu-id="fd3ea-112">Abbiamo deciso di abbandonare questo modello a favore di un approccio ibrido che offre diversi vantaggi rispetto alle implementazioni singleton tradizionali con `MonoBehaviours` , ovvero:</span><span class="sxs-lookup"><span data-stu-id="fd3ea-112">We've decided to break away from this pattern in favor of a hybrid approach that brings several benefits over the traditional singleton implementations with `MonoBehaviours`, namely:</span></span>

* <span data-ttu-id="fd3ea-113">Prestazioni: senza l'overhead di un `MonoBehaviour` , [gli aggiornamenti degli script sono più veloci circa il 80% e non richiedono un `GameObject` per vivere nella scena](https://blogs.unity3d.com/2015/12/23/1k-update-calls/).</span><span class="sxs-lookup"><span data-stu-id="fd3ea-113">Performance - without the overhead of a `MonoBehaviour`, [script updates are approximately 80% faster and don't require a `GameObject` to live in the scene](https://blogs.unity3d.com/2015/12/23/1k-update-calls/).</span></span>
* <span data-ttu-id="fd3ea-114">Reference-Capacity: i servizi possono essere individuati dalla `MixedRealityToolkit` molto più veloce e più semplice rispetto alla ricerca `GameObjects` in una scena o all'uso di `FindObjectsOfType<T>` .</span><span class="sxs-lookup"><span data-stu-id="fd3ea-114">Reference-ability - services can be discovered from the `MixedRealityToolkit` a lot faster and easier than searching `GameObjects` in a scene or using `FindObjectsOfType<T>`.</span></span>
* <span data-ttu-id="fd3ea-115">Nessuna dipendenza di tipo: Sebbene un metodo simile all'inserimento delle dipendenze, i servizi possano essere separati dal tipo, ciò significa che l'implementazione concreta può essere scambiata in qualsiasi momento senza influire negativamente sul codice che lo utilizza, ad esempio sostituendo il InputSystem predefinito con quello personalizzato, purché sia stata implementata completamente ogni interfaccia.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-115">No type dependency - though a method similar to dependency injection, services can be decoupled from their type, this means the concrete implementation can be swapped out at any time without adversely affecting code that consumes it (e.g. replacing the default InputSystem with your custom one, so long as you've fully implemented each interface).</span></span>
* <span data-ttu-id="fd3ea-116">Utilizzo multiscena: se un servizio deve essere a conoscenza di una `transform` posizione in una scena, può semplicemente fare riferimento o creare, `GameObject` _anziché essere un componente associato_.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-116">Multi-scene usage - if a service does need to know about a `transform` position in a scene, it can simply reference, or create, a `GameObject` _rather than be a component attached to it_.</span></span> <span data-ttu-id="fd3ea-117">Questo rende molto più semplice trovare e usare il servizio quando il progetto si estende su più scene.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-117">This makes it a lot easier to find and use the service when the project spans multiple scenes.</span></span>

## <a name="service-interfaces"></a><span data-ttu-id="fd3ea-118">Interfacce del servizio</span><span class="sxs-lookup"><span data-stu-id="fd3ea-118">Service interfaces</span></span>

<span data-ttu-id="fd3ea-119">Il contenitore di *Servizi* utilizza un tipo di *interfaccia* predefinito per l'archiviazione e il recupero di qualsiasi servizio, in modo da garantire che non esistano dipendenze rigide nel Toolkit di realtà mista, in modo che ogni sottosistema possa essere facilmente scambiato con un altro (purché sia conforme all'interfaccia).</span><span class="sxs-lookup"><span data-stu-id="fd3ea-119">The *service* container uses a predefined *interface* type for storage and retrieval of any service, this ensures there are no hard dependencies within the Mixed Reality Toolkit, so that each subsystem can easily be swapped out with another (so long as it conforms to the interface).</span></span>

<span data-ttu-id="fd3ea-120">Le interfacce di sistema correnti fornite dal Toolkit per la realtà mista includono:</span><span class="sxs-lookup"><span data-stu-id="fd3ea-120">Current system interfaces provided by the Mixed Reality Toolkit include:</span></span>

* [`IMixedRealityInputSystem`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityInputSystem)
* [`IMixedRealityBoundarySystem`](xref:Microsoft.MixedReality.Toolkit.Boundary.IMixedRealityBoundarySystem)
* [`IMixedRealityTeleportSystem`](xref:Microsoft.MixedReality.Toolkit.Teleport.IMixedRealityTeleportSystem)

<span data-ttu-id="fd3ea-121">Quando si creano implementazioni personalizzate di questi sistemi, è necessario assicurarsi che ogni sia conforme alle interfacce fornite dal Toolkit di realtà mista (ad esempio, se si sostituisce InputSystem con un'altra progettazione).</span><span class="sxs-lookup"><span data-stu-id="fd3ea-121">When creating your own implementations of these systems, you must ensure each complies with the interfaces provided by the Mixed Reality Toolkit (e.g. if you replace the InputSystem with another of your own design).</span></span>

> [!NOTE]
> <span data-ttu-id="fd3ea-122">Tutti i servizi devono anche ereditare dalla [`BaseService`](xref:Microsoft.MixedReality.Toolkit.BaseService) classe o implementare [`IMixedRealityService`](xref:Microsoft.MixedReality.Toolkit.IMixedRealityService) , per implementare le funzioni richieste da, in `MixedRealityToolkit` modo che i cicli di vita vengano gestiti in modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-122">All services must also inherit from the [`BaseService`](xref:Microsoft.MixedReality.Toolkit.BaseService) class or implement [`IMixedRealityService`](xref:Microsoft.MixedReality.Toolkit.IMixedRealityService), to implement the functions required by the `MixedRealityToolkit` so their life-cycles are handled appropriately.</span></span> <span data-ttu-id="fd3ea-123">es.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-123">(E.G.</span></span> <span data-ttu-id="fd3ea-124">Initialize, Update e Destroy vengono chiamati correttamente.</span><span class="sxs-lookup"><span data-stu-id="fd3ea-124">Initialize, Update, Destroy are called correctly.)</span></span>
