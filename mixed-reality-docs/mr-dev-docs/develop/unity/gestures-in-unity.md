---
title: Movimenti in Unity
description: Informazioni su come intervenire sullo sguardo in Unity con l'input del gesto manuale usando XR e le API comuni di pulsanti e assi.
author: hferrone
ms.author: alexturn
ms.date: 12/1/2020
ms.topic: article
keywords: movimenti, Unity, sguardo, input, auricolare realtà mista, auricolare di realtà mista di Windows, cuffia virtuale reale, MRTK, Toolkit di realtà mista
ms.openlocfilehash: 523f05f9b3dd05a140bb40168b654a2dc0b00bb5
ms.sourcegitcommit: 1c9035487270af76c6eaba11b11f6fc56c008135
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/13/2021
ms.locfileid: "107299716"
---
# <a name="gestures-in-unity"></a><span data-ttu-id="2fa4f-104">Movimenti in Unity</span><span class="sxs-lookup"><span data-stu-id="2fa4f-104">Gestures in Unity</span></span>

<span data-ttu-id="2fa4f-105">Ci sono due modi principali per agire sullo [sguardo in Unity](gaze-in-unity.md), [movimenti della mano](../../design/gaze-and-commit.md#composite-gestures) e [controller di movimento](../../design/motion-controllers.md) in HoloLens e HMD immersivi.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-105">There are two key ways to take action on your [gaze in Unity](gaze-in-unity.md), [hand gestures](../../design/gaze-and-commit.md#composite-gestures) and [motion controllers](../../design/motion-controllers.md) in HoloLens and Immersive HMD.</span></span> <span data-ttu-id="2fa4f-106">È possibile accedere ai dati per entrambe le origini dell'input spaziale tramite le stesse API in Unity.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-106">You access the data for both sources of spatial input through the same APIs in Unity.</span></span>

<span data-ttu-id="2fa4f-107">Unity offre due modi principali per accedere ai dati di input spaziali per la realtà mista di Windows.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-107">Unity provides two primary ways to access spatial input data for Windows Mixed Reality.</span></span> <span data-ttu-id="2fa4f-108">Le API *input. GetButton/input. getaxis* comuni sono compatibili con più SDK di Unity XR, mentre l'API *InteractionManager/GestureRecognizer* specifica di Windows Mixed Reality espone il set completo di dati di input spaziali.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-108">The common *Input.GetButton/Input.GetAxis* APIs work across multiple Unity XR SDKs, while the *InteractionManager/GestureRecognizer* API specific to Windows Mixed Reality exposes the full set of spatial input data.</span></span>

## <a name="high-level-composite-gesture-apis-gesturerecognizer"></a><span data-ttu-id="2fa4f-109">API per movimenti compositi di alto livello (GestureRecognizer)</span><span class="sxs-lookup"><span data-stu-id="2fa4f-109">High-level composite gesture APIs (GestureRecognizer)</span></span>

<span data-ttu-id="2fa4f-110">**Spazio dei nomi:** *UnityEngine. XR. WSA. input*</span><span class="sxs-lookup"><span data-stu-id="2fa4f-110">**Namespace:** *UnityEngine.XR.WSA.Input*</span></span><br>
<span data-ttu-id="2fa4f-111">**Tipi**: *GestureRecognizer*, *GestureSettings*, *InteractionSourceKind*</span><span class="sxs-lookup"><span data-stu-id="2fa4f-111">**Types**: *GestureRecognizer*, *GestureSettings*, *InteractionSourceKind*</span></span>

<span data-ttu-id="2fa4f-112">L'app può anche riconoscere movimenti compositi di livello superiore per le origini di input spaziali, i movimenti di tocco, di manipolazione e di navigazione.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-112">Your app can also recognize higher-level composite gestures for spatial input sources, Tap, Hold, Manipulation, and Navigation gestures.</span></span> <span data-ttu-id="2fa4f-113">È possibile riconoscere questi movimenti compositi tra [le mani](../../design/gaze-and-commit.md#composite-gestures) e i [controller di movimento](../../design/motion-controllers.md) usando l'oggetto GestureRecognizer.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-113">You can recognize these composite gestures across both [hands](../../design/gaze-and-commit.md#composite-gestures) and [motion controllers](../../design/motion-controllers.md) using the GestureRecognizer.</span></span>

<span data-ttu-id="2fa4f-114">Ogni evento di movimento nell'oggetto GestureRecognizer fornisce SourceKind per l'input, nonché il raggio Head di destinazione al momento dell'evento.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-114">Each Gesture event on the GestureRecognizer provides the SourceKind for the input as well as the targeting head ray at the time of the event.</span></span> <span data-ttu-id="2fa4f-115">Alcuni eventi forniscono informazioni aggiuntive specifiche del contesto.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-115">Some events provide additional context-specific information.</span></span>

<span data-ttu-id="2fa4f-116">Sono necessari solo pochi passaggi per acquisire i movimenti usando un riconoscitore di movimento:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-116">There are only a few steps required to capture gestures using a Gesture Recognizer:</span></span>
1. <span data-ttu-id="2fa4f-117">Creare un nuovo riconoscitore di movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-117">Create a new Gesture Recognizer</span></span>
2. <span data-ttu-id="2fa4f-118">Specificare i movimenti da controllare</span><span class="sxs-lookup"><span data-stu-id="2fa4f-118">Specify which gestures to watch for</span></span>
3. <span data-ttu-id="2fa4f-119">Sottoscrivere gli eventi per questi movimenti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-119">Subscribe to events for those gestures</span></span>
4. <span data-ttu-id="2fa4f-120">Avviare l'acquisizione di movimenti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-120">Start capturing gestures</span></span>

### <a name="create-a-new-gesture-recognizer"></a><span data-ttu-id="2fa4f-121">Creare un nuovo riconoscitore di movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-121">Create a new Gesture Recognizer</span></span>

<span data-ttu-id="2fa4f-122">Per utilizzare l'oggetto *GestureRecognizer*, è necessario avere creato un oggetto *GestureRecognizer*:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-122">To use the *GestureRecognizer*, you must have created a *GestureRecognizer*:</span></span>

```cs
GestureRecognizer recognizer = new GestureRecognizer();
```

### <a name="specify-which-gestures-to-watch-for"></a><span data-ttu-id="2fa4f-123">Specificare i movimenti da controllare</span><span class="sxs-lookup"><span data-stu-id="2fa4f-123">Specify which gestures to watch for</span></span>

<span data-ttu-id="2fa4f-124">Specificare i movimenti a cui si è interessati tramite *SetRecognizableGestures ()*:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-124">Specify which gestures you're interested in via *SetRecognizableGestures()*:</span></span>

```cs
recognizer.SetRecognizableGestures(GestureSettings.Tap | GestureSettings.Hold);
```

### <a name="subscribe-to-events-for-those-gestures"></a><span data-ttu-id="2fa4f-125">Sottoscrivere gli eventi per questi movimenti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-125">Subscribe to events for those gestures</span></span>

<span data-ttu-id="2fa4f-126">Sottoscrivere gli eventi per i movimenti a cui si è interessati.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-126">Subscribe to events for the gestures you're interested in.</span></span>

```cs
void Start()
{
    recognizer.Tapped += GestureRecognizer_Tapped;
    recognizer.HoldStarted += GestureRecognizer_HoldStarted;
    recognizer.HoldCompleted += GestureRecognizer_HoldCompleted;
    recognizer.HoldCanceled += GestureRecognizer_HoldCanceled;
}
```

>[!NOTE]
><span data-ttu-id="2fa4f-127">I movimenti di spostamento e manipolazione si escludono a vicenda in un'istanza di un oggetto *GestureRecognizer*.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-127">Navigation and Manipulation gestures are mutually exclusive on an instance of a *GestureRecognizer*.</span></span>

### <a name="start-capturing-gestures"></a><span data-ttu-id="2fa4f-128">Avviare l'acquisizione di movimenti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-128">Start capturing gestures</span></span>

<span data-ttu-id="2fa4f-129">Per impostazione predefinita, un oggetto *GestureRecognizer* non monitora l'input fino a quando non viene chiamato *StartCapturingGestures ()* .</span><span class="sxs-lookup"><span data-stu-id="2fa4f-129">By default, a *GestureRecognizer* doesn't monitor input until *StartCapturingGestures()* is called.</span></span> <span data-ttu-id="2fa4f-130">È possibile che venga generato un evento di movimento dopo che è stato chiamato *StopCapturingGestures ()* se l'input è stato eseguito prima del frame in cui è stato elaborato *StopCapturingGestures ()* .</span><span class="sxs-lookup"><span data-stu-id="2fa4f-130">It's possible that a gesture event may be generated after *StopCapturingGestures()* is called if input was performed before the frame where *StopCapturingGestures()* was processed.</span></span> <span data-ttu-id="2fa4f-131">L'oggetto *GestureRecognizer* ricorda se è stato acceso o disattivato durante il frame precedente in cui si è effettivamente verificato il movimento ed è quindi affidabile per avviare e arrestare il monitoraggio dei movimenti in base alla destinazione dello sguardo del frame.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-131">The *GestureRecognizer* will remember whether it was on or off during the previous frame in which the gesture actually occurred, and so it's reliable to start and stop gesture monitoring based on this frame's gaze targeting.</span></span>

```cs
recognizer.StartCapturingGestures();
```

### <a name="stop-capturing-gestures"></a><span data-ttu-id="2fa4f-132">Interrompi acquisizione movimenti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-132">Stop capturing gestures</span></span>

<span data-ttu-id="2fa4f-133">Per arrestare il riconoscimento del movimento:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-133">To stop gesture recognition:</span></span>

```cs
recognizer.StopCapturingGestures();
```

### <a name="removing-a-gesture-recognizer"></a><span data-ttu-id="2fa4f-134">Rimozione di un riconoscimento di movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-134">Removing a gesture recognizer</span></span>

<span data-ttu-id="2fa4f-135">Ricordarsi di annullare la sottoscrizione agli eventi sottoscritti prima di eliminare un oggetto *GestureRecognizer* .</span><span class="sxs-lookup"><span data-stu-id="2fa4f-135">Remember to unsubscribe from subscribed events before destroying a *GestureRecognizer* object.</span></span>

```cs
void OnDestroy()
{
    recognizer.Tapped -= GestureRecognizer_Tapped;
    recognizer.HoldStarted -= GestureRecognizer_HoldStarted;
    recognizer.HoldCompleted -= GestureRecognizer_HoldCompleted;
    recognizer.HoldCanceled -= GestureRecognizer_HoldCanceled;
}
```

## <a name="rendering-the-motion-controller-model-in-unity"></a><span data-ttu-id="2fa4f-136">Rendering del modello di controller di movimento in Unity</span><span class="sxs-lookup"><span data-stu-id="2fa4f-136">Rendering the motion controller model in Unity</span></span>

<span data-ttu-id="2fa4f-137">![Modello e teleporting del controller di movimento](images/motioncontrollertest-teleport-1000px.png)</span><span class="sxs-lookup"><span data-stu-id="2fa4f-137">![Motion Controller model and teleportation](images/motioncontrollertest-teleport-1000px.png)</span></span><br>
<span data-ttu-id="2fa4f-138">*Modello e teleporting del controller di movimento*</span><span class="sxs-lookup"><span data-stu-id="2fa4f-138">*Motion controller model and teleportation*</span></span>

<span data-ttu-id="2fa4f-139">Per eseguire il rendering dei controller di movimento nell'app che corrispondono ai controller fisici che gli utenti mantengono e si articolano con la pressione di vari pulsanti, è possibile usare la **prefabbricazione MotionController** nel [Toolkit di realtà mista](https://github.com/Microsoft/MixedRealityToolkit-Unity/).</span><span class="sxs-lookup"><span data-stu-id="2fa4f-139">To render motion controllers in your app that match the physical controllers your users are holding and articulate as various buttons are pressed, you can use the **MotionController prefab** in the [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity/).</span></span>  <span data-ttu-id="2fa4f-140">Questa prefabbricata carica dinamicamente il modello glTF corretto in fase di esecuzione dal driver del controller di movimento installato dal sistema.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-140">This prefab dynamically loads the correct glTF model at runtime from the system's installed motion controller driver.</span></span>  <span data-ttu-id="2fa4f-141">È importante caricare i modelli in modo dinamico, anziché importarli manualmente nell'editor, in modo che l'app visualizzi modelli 3D fisicamente accurati per i controller correnti e futuri che possono avere gli utenti.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-141">It's important to load these models dynamically rather than importing them manually in the editor, so that your app will show physically accurate 3D models for any current and future controllers your users may have.</span></span>

1. <span data-ttu-id="2fa4f-142">Seguire le istruzioni [Introduzione](https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/htk_release/GettingStarted.md) per scaricare il Toolkit di realtà mista e aggiungerlo al progetto Unity.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-142">Follow the [Getting Started](https://github.com/Microsoft/MixedRealityToolkit-Unity/blob/htk_release/GettingStarted.md) instructions to download the Mixed Reality Toolkit and add it to your Unity project.</span></span>
2. <span data-ttu-id="2fa4f-143">Se la fotocamera è stata sostituita con la prefabbricata *MixedRealityCameraParent* come parte del Introduzione passaggi, è possibile iniziare.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-143">If you replaced your camera with the *MixedRealityCameraParent* prefab as part of the Getting Started steps, you're good to go!</span></span>  <span data-ttu-id="2fa4f-144">Il prefabbricato include il rendering del controller di movimento.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-144">That prefab includes motion controller rendering.</span></span>  <span data-ttu-id="2fa4f-145">In caso contrario, aggiungere *assets/HoloToolkit/input/precasers/MotionControllers. prefabbricate* nella scena dal riquadro progetto.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-145">Otherwise, add *Assets/HoloToolkit/Input/Prefabs/MotionControllers.prefab* into your scene from the Project pane.</span></span>  <span data-ttu-id="2fa4f-146">È opportuno aggiungere tale prefabbricato come elemento figlio di qualsiasi oggetto padre utilizzato per spostare la fotocamera quando l'utente esegue il teleportamento all'interno della scena, in modo che i controller siano insieme all'utente.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-146">You'll want to add that prefab as a child of whatever parent object you use to move the camera around when the user teleports within your scene, so that the controllers come along with the user.</span></span>  <span data-ttu-id="2fa4f-147">Se l'app non implica il Teleporting, è sufficiente aggiungere il prefabbricato alla radice della scena.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-147">If your app doesn't involve teleporting, just add the prefab at the root of your scene.</span></span>

## <a name="throwing-objects"></a><span data-ttu-id="2fa4f-148">Generazione di oggetti</span><span class="sxs-lookup"><span data-stu-id="2fa4f-148">Throwing objects</span></span>

<span data-ttu-id="2fa4f-149">La generazione di oggetti in realtà virtuale è un problema più difficile rispetto a quello che può sembrare inizialmente.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-149">Throwing objects in virtual reality is a harder problem than it may at first seem.</span></span> <span data-ttu-id="2fa4f-150">Come per la maggior parte delle interazioni basate fisicamente, quando la generazione di un gioco agisce in modo imprevisto, è immediatamente evidente e interrompe l'immersione.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-150">As with most physically based interactions, when throwing in game acts in an unexpected way, it's immediately obvious and breaks immersion.</span></span> <span data-ttu-id="2fa4f-151">Abbiamo dedicato un po' di tempo a comprendere in modo approfondito come rappresentare un comportamento di generazione fisico corretto e avere a disposizione alcune linee guida, abilitate tramite aggiornamenti alla piattaforma, che vogliamo condividere con te.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-151">We've spent some time thinking deeply about how to represent a physically correct throwing behavior, and have come up with a few guidelines, enabled through updates to our platform, that we would like to share with you.</span></span>

<span data-ttu-id="2fa4f-152">È possibile trovare un esempio di come si consiglia di implementare il lancio [qui](https://github.com/keluecke/MixedRealityToolkit-Unity/blob/master/External/Unitypackages/ThrowingStarter.unitypackage).</span><span class="sxs-lookup"><span data-stu-id="2fa4f-152">You can find an example of how we recommend to implement throwing [here](https://github.com/keluecke/MixedRealityToolkit-Unity/blob/master/External/Unitypackages/ThrowingStarter.unitypackage).</span></span> <span data-ttu-id="2fa4f-153">Questo esempio segue le quattro linee guida seguenti:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-153">This sample follows these four guidelines:</span></span>
* <span data-ttu-id="2fa4f-154">**Utilizzare la *velocità* del controller invece della posizione**.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-154">**Use the controller’s *velocity* instead of position**.</span></span> <span data-ttu-id="2fa4f-155">Nell'aggiornamento di novembre di Windows è stata introdotta una modifica nel comportamento quando si [Verifica lo stato di rilevamento posizionale '' approssimativo](../../design/motion-controllers.md#controller-tracking-state).</span><span class="sxs-lookup"><span data-stu-id="2fa4f-155">In the November update to Windows, we introduced a change in behavior when in the [''Approximate'' positional tracking state](../../design/motion-controllers.md#controller-tracking-state).</span></span> <span data-ttu-id="2fa4f-156">In questo stato, le informazioni sulla velocità del controller continueranno a essere segnalate fino a quando riteniamo che la sua accuratezza elevata, che è spesso più lunga della posizione, resta alta accuratezza.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-156">When in this state, velocity information about the controller will continue to be reported for as long as we believe its high accuracy, which is often longer than position remains high accuracy.</span></span>
* <span data-ttu-id="2fa4f-157">**Incorporare la *velocità angolare* del controller**.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-157">**Incorporate the *angular velocity* of the controller**.</span></span> <span data-ttu-id="2fa4f-158">Questa logica è interamente contenuta nel `throwing.cs` file nel `GetThrownObjectVelAngVel` metodo statico, all'interno del pacchetto collegato sopra:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-158">This logic is all contained in the `throwing.cs` file in the `GetThrownObjectVelAngVel` static method, within the package linked above:</span></span>
   1. <span data-ttu-id="2fa4f-159">Poiché viene mantenuta la velocità angolare, l'oggetto generato deve mantenere la stessa velocità angolare del momento in cui si trovava al momento della generazione: `objectAngularVelocity = throwingControllerAngularVelocity;`</span><span class="sxs-lookup"><span data-stu-id="2fa4f-159">As angular velocity is conserved, the thrown object must maintain the same angular velocity as it had at the moment of the throw: `objectAngularVelocity = throwingControllerAngularVelocity;`</span></span>
   2. <span data-ttu-id="2fa4f-160">Poiché il centro della massa dell'oggetto generato è probabilmente diverso dall'origine della posizione del grip, è probabile che abbia una velocità diversa rispetto a quella del controller nel frame di riferimento dell'utente.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-160">As the center of mass of the thrown object is likely not at the origin of the grip pose, it likely has a different velocity than that of the controller in the frame of reference of the user.</span></span> <span data-ttu-id="2fa4f-161">La parte della velocità dell'oggetto contribuito in questo modo è la velocità tangenziale istantanea del centro della massa dell'oggetto generato intorno all'origine del controller.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-161">The portion of the object’s velocity contributed in this way is the instantaneous tangential velocity of the center of mass of the thrown object around the controller origin.</span></span> <span data-ttu-id="2fa4f-162">Questa velocità tangenziale è il prodotto incrociato della velocità angolare del controller con il vettore che rappresenta la distanza tra l'origine del controller e il centro della massa dell'oggetto generato.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-162">This tangential velocity is the cross product of the angular velocity of the controller with the vector representing the distance between the controller origin and the center of mass of the thrown object.</span></span>

      ```cs
      Vector3 radialVec = thrownObjectCenterOfMass - throwingControllerPos;
      Vector3 tangentialVelocity = Vector3.Cross(throwingControllerAngularVelocity, radialVec);
      ```

   3. <span data-ttu-id="2fa4f-163">La velocità totale dell'oggetto generata è la somma della velocità del controller e della velocità tangenziale: `objectVelocity = throwingControllerVelocity + tangentialVelocity;`</span><span class="sxs-lookup"><span data-stu-id="2fa4f-163">The total velocity of the thrown object is the sum of velocity of the controller and this tangential velocity: `objectVelocity = throwingControllerVelocity + tangentialVelocity;`</span></span>

* <span data-ttu-id="2fa4f-164">**Prestare particolare attenzione all' *ora* in cui viene applicata la velocità**.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-164">**Pay close attention to the *time* at which we apply the velocity**.</span></span> <span data-ttu-id="2fa4f-165">Quando si preme un pulsante, l'evento può richiedere fino a 20 ms per la propagazione tramite Bluetooth al sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-165">When a button is pressed, it can take up to 20 ms for that event to bubble up through Bluetooth to the operating system.</span></span> <span data-ttu-id="2fa4f-166">Ciò significa che se si esegue il polling di una modifica dello stato del controller da Pressed a not Pressed o viceversa, il controller pone le informazioni che verranno apportate in precedenza in questa modifica dello stato.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-166">This means that if you poll for a controller state change from pressed to not pressed or the other way around, the controller pose information you get with it will actually be ahead of this change in state.</span></span> <span data-ttu-id="2fa4f-167">Inoltre, la formula del controller presentata dall'API di polling viene stimata in modo da riflettere un probabile posto nel momento in cui verrà visualizzato il frame che potrebbe essere più di 20 ms in futuro.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-167">Further, the controller pose presented by our polling API is forward predicted to reflect a likely pose at the time the frame will be displayed which could be more than 20 ms in the future.</span></span> <span data-ttu-id="2fa4f-168">Questo è ideale per il *rendering* degli oggetti conservati, ma costituisce un problema di tempo per la *destinazione* dell'oggetto durante il calcolo della traiettoria nel momento in cui l'utente ha rilasciato il Throw.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-168">This is good for *rendering* held objects, but compounds our time problem for *targeting* the object as we calculate the trajectory for the moment the user released the throw.</span></span> <span data-ttu-id="2fa4f-169">Fortunatamente, con l'aggiornamento di novembre, quando viene inviato un evento Unity, ad esempio *InteractionSourcePressed* o *InteractionSourceReleased* , lo stato include i dati di post cronologici da indietro quando il pulsante è stato premuto o rilasciato.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-169">Fortunately, with the November update, when a Unity event like *InteractionSourcePressed* or *InteractionSourceReleased* is sent, the state includes the historical pose data from back when the button was pressed or released.</span></span>  <span data-ttu-id="2fa4f-170">Per ottenere il rendering del controller più accurato e la destinazione del controller durante i lanci, è necessario usare correttamente il polling e la gestione degli eventi, in base alle esigenze:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-170">To get the most accurate controller rendering and controller targeting during throws, you must correctly use polling and eventing, as appropriate:</span></span>
   * <span data-ttu-id="2fa4f-171">Per il **rendering del controller** ogni frame, l'app deve posizionare il *GameObject* del controller in corrispondenza del controller con stima avanzata per l'ora del fotone del frame corrente.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-171">For **controller rendering** each frame, your app should position the controller's *GameObject* at the forward-predicted controller pose for the current frame’s photon time.</span></span>  <span data-ttu-id="2fa4f-172">Si ottengono questi dati dalle API di polling Unity, ad esempio *[XR. InputTracking. GetLocalPosition](https://docs.unity3d.com/ScriptReference/XR.InputTracking.GetLocalPosition.html)* o *[XR. WSA. Input. InteractionManager. GetCurrentReading](https://docs.unity3d.com/ScriptReference/XR.WSA.Input.InteractionManager.GetCurrentReading.html)*.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-172">You get this data from Unity polling APIs like *[XR.InputTracking.GetLocalPosition](https://docs.unity3d.com/ScriptReference/XR.InputTracking.GetLocalPosition.html)* or *[XR.WSA.Input.InteractionManager.GetCurrentReading](https://docs.unity3d.com/ScriptReference/XR.WSA.Input.InteractionManager.GetCurrentReading.html)*.</span></span>
   * <span data-ttu-id="2fa4f-173">Per il **controller che punta** alla stampa o al rilascio, l'app deve Raycast e calcolare le traiettorie in base alla definizione del controller cronologico per l'evento di stampa o di rilascio.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-173">For **controller targeting** upon a press or release, your app should raycast and calculate trajectories based on the historical controller pose for that press or release event.</span></span>  <span data-ttu-id="2fa4f-174">Si ottengono questi dati dalle API di gestione degli eventi di Unity, ad esempio *[InteractionManager. InteractionSourcePressed](https://docs.unity3d.com/ScriptReference/XR.WSA.Input.InteractionManager.InteractionSourcePressed.html)*.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-174">You get this data from Unity eventing APIs, like *[InteractionManager.InteractionSourcePressed](https://docs.unity3d.com/ScriptReference/XR.WSA.Input.InteractionManager.InteractionSourcePressed.html)*.</span></span>
* <span data-ttu-id="2fa4f-175">**Utilizzare la disposizione del grip**.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-175">**Use the grip pose**.</span></span> <span data-ttu-id="2fa4f-176">La velocità e la velocità angolari vengono segnalate rispetto alla posizione del grip, non alla posizione del puntatore.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-176">Angular velocity and velocity are reported relative to the grip pose, not pointer pose.</span></span>

<span data-ttu-id="2fa4f-177">La generazione continuerà a migliorare con gli aggiornamenti futuri di Windows e ci si aspetterà di trovare altre informazioni su di essa.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-177">Throwing will continue to improve with future Windows updates, and you can expect to find more information on it here.</span></span>

## <a name="gesture-and-motion-controllers-in-mrtk"></a><span data-ttu-id="2fa4f-178">Controller movimento e movimento in MRTK</span><span class="sxs-lookup"><span data-stu-id="2fa4f-178">Gesture and Motion Controllers in MRTK</span></span>

<span data-ttu-id="2fa4f-179">È possibile accedere a gesture e Motion controller dal gestore di input.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-179">You can access gesture and motion controller from the input Manager.</span></span>

* [<span data-ttu-id="2fa4f-180">Movimento in MRTK</span><span class="sxs-lookup"><span data-stu-id="2fa4f-180">Gesture in MRTK</span></span>](https://docs.microsoft.com/windows/mixed-reality/mrtk-unity/features/input/gestures)
* [<span data-ttu-id="2fa4f-181">Controller di movimento in MRTK</span><span class="sxs-lookup"><span data-stu-id="2fa4f-181">Motion Controller in MRTK</span></span>](https://docs.microsoft.com/windows/mixed-reality/mrtk-unity/features/input/controllers)

## <a name="follow-along-with-tutorials"></a><span data-ttu-id="2fa4f-182">Seguire le esercitazioni</span><span class="sxs-lookup"><span data-stu-id="2fa4f-182">Follow along with tutorials</span></span>

<span data-ttu-id="2fa4f-183">Le esercitazioni dettagliate, con esempi di personalizzazione più dettagliati, sono disponibili in Mixed Reality Academy:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-183">Step-by-step tutorials, with more detailed customization examples, are available in the Mixed Reality Academy:</span></span>

- [<span data-ttu-id="2fa4f-184">Input MR 211: Movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-184">MR Input 211: Gesture</span></span>](tutorials/holograms-211.md)
- [<span data-ttu-id="2fa4f-185">Input MR 213: Controller del movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-185">MR Input 213: Motion controllers</span></span>](../../deprecated/mixed-reality-213.md)

<span data-ttu-id="2fa4f-186">[![Input MR 213-controller di movimento](images/mr213-main-600px.jpg)](/windows/mixed-reality/mixed-reality-213)</span><span class="sxs-lookup"><span data-stu-id="2fa4f-186">[![MR Input 213 - Motion controller](images/mr213-main-600px.jpg)](/windows/mixed-reality/mixed-reality-213)</span></span><br>
<span data-ttu-id="2fa4f-187">*Input MR 213-controller di movimento*</span><span class="sxs-lookup"><span data-stu-id="2fa4f-187">*MR Input 213 - Motion controller*</span></span>

## <a name="next-development-checkpoint"></a><span data-ttu-id="2fa4f-188">Successivo checkpoint di sviluppo</span><span class="sxs-lookup"><span data-stu-id="2fa4f-188">Next Development Checkpoint</span></span>

<span data-ttu-id="2fa4f-189">Se si sta seguendo il percorso di sviluppo di Unity, si sta per esplorare i blocchi predefiniti di MRTK core.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-189">If you're following the Unity development journey we've laid out, you're in the midst of exploring the MRTK core building blocks.</span></span> <span data-ttu-id="2fa4f-190">Da qui è possibile passare al blocco predefinito successivo:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-190">From here, you can continue to the next building block:</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="2fa4f-191">Tracciamento della mano e oculare</span><span class="sxs-lookup"><span data-stu-id="2fa4f-191">Hand and eye tracking</span></span>](./hand-eye-in-unity.md)

<span data-ttu-id="2fa4f-192">In alternativa, passare alle API e funzionalità della piattaforma di realtà mista:</span><span class="sxs-lookup"><span data-stu-id="2fa4f-192">Or jump to Mixed Reality platform capabilities and APIs:</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="2fa4f-193">Esperienze condivise</span><span class="sxs-lookup"><span data-stu-id="2fa4f-193">Shared experiences</span></span>](shared-experiences-in-unity.md)

<span data-ttu-id="2fa4f-194">È sempre possibile tornare ai [checkpoint per lo sviluppo con Unity](unity-development-overview.md#2-core-building-blocks) in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="2fa4f-194">You can always go back to the [Unity development checkpoints](unity-development-overview.md#2-core-building-blocks) at any time.</span></span>

## <a name="see-also"></a><span data-ttu-id="2fa4f-195">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="2fa4f-195">See also</span></span>

* [<span data-ttu-id="2fa4f-196">Puntamento con la testa e commit</span><span class="sxs-lookup"><span data-stu-id="2fa4f-196">Head-gaze and commit</span></span>](../../design/gaze-and-commit.md)
* [<span data-ttu-id="2fa4f-197">Controller del movimento</span><span class="sxs-lookup"><span data-stu-id="2fa4f-197">Motion controllers</span></span>](../../design/motion-controllers.md)