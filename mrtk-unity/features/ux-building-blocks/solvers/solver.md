---
title: Solver
description: Panoramica dei risolutori in MRTK
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity, HoloLens, HoloLens 2, realtà mista, sviluppo, MRTK, risolutori,
ms.openlocfilehash: a9ca6d025fa4261bb9b5398cb4c7b82a5f6ff8f0
ms.sourcegitcommit: 59c91f8c70d1ad30995fba6cf862615e25e78d10
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/19/2021
ms.locfileid: "102770349"
---
# <a name="solvers"></a><span data-ttu-id="570c4-104">Risolutori</span><span class="sxs-lookup"><span data-stu-id="570c4-104">Solvers</span></span>

![Principale Risolutore](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="570c4-106">I resolver sono componenti che facilitano il calcolo della posizione di un oggetto & orientamento in base a un algoritmo predefinito.</span><span class="sxs-lookup"><span data-stu-id="570c4-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="570c4-107">Un esempio potrebbe essere l'inserimento di un oggetto sulla superficie a cui si riferisce lo sguardo Raycast dell'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="570c4-108">Inoltre, il sistema di Risolutore definisce in modo deterministico un ordine di operazioni per questi calcoli di trasformazione, perché non esiste un modo affidabile per specificare l'ordine di aggiornamento per i componenti in Unity.</span><span class="sxs-lookup"><span data-stu-id="570c4-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="570c4-109">I risolutori offrono una gamma di comportamenti per aggiungere oggetti ad altri oggetti o sistemi.</span><span class="sxs-lookup"><span data-stu-id="570c4-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="570c4-110">Un altro esempio è un oggetto con tag che passa davanti all'utente (in base alla fotocamera).</span><span class="sxs-lookup"><span data-stu-id="570c4-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="570c4-111">Un Risolutore può anche essere collegato a un controller e a un oggetto per rendere il tag oggetto lungo il controller.</span><span class="sxs-lookup"><span data-stu-id="570c4-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="570c4-112">Tutti i risolutori possono essere impilati in modo sicuro, ad esempio un comportamento di tag lungo e un magnetismo di superficie + momento.</span><span class="sxs-lookup"><span data-stu-id="570c4-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="570c4-113">Come usare un risolutore</span><span class="sxs-lookup"><span data-stu-id="570c4-113">How to use a solver</span></span>

<span data-ttu-id="570c4-114">Il sistema del Risolutore è costituito da tre categorie di script:</span><span class="sxs-lookup"><span data-stu-id="570c4-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="570c4-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): Classe astratta di base da cui derivano tutti i resolver.</span><span class="sxs-lookup"><span data-stu-id="570c4-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="570c4-116">Fornisce il rilevamento dello stato, l'implementazione e i parametri di smoothing, l'integrazione automatica del sistema di risoluzione e l'ordine di aggiornamento.</span><span class="sxs-lookup"><span data-stu-id="570c4-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="570c4-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Imposta l'oggetto di riferimento da rilevare (ad esempio, la trasformazione della fotocamera principale, il raggio della mano e così via), gestisce la raccolta dei componenti del Risolutore ed esegue l'aggiornamento nell'ordine corretto.</span><span class="sxs-lookup"><span data-stu-id="570c4-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="570c4-118">La terza categoria è il Risolutore.</span><span class="sxs-lookup"><span data-stu-id="570c4-118">The third category is the solver itself.</span></span> <span data-ttu-id="570c4-119">I risolutori seguenti forniscono i blocchi predefiniti per il comportamento di base:</span><span class="sxs-lookup"><span data-stu-id="570c4-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="570c4-120">[`Orbital`](#orbital): Blocca a una posizione e un offset specificati dall'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="570c4-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="570c4-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scala per mantenere una dimensione costante rispetto alla visualizzazione dell'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="570c4-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="570c4-122">[`RadialView`](#radialview): Mantiene l'oggetto all'interno di un cono di visualizzazione sottomesso a cast dall'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="570c4-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="570c4-123">[`Follow`](#follow): Mantiene l'oggetto all'interno di un set di limiti definiti dall'utente dell'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="570c4-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="570c4-124">[`InBetween`](#inbetween): Mantiene un oggetto tra due oggetti rilevati.</span><span class="sxs-lookup"><span data-stu-id="570c4-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="570c4-125">[`SurfaceMagnetism`](#surfacemagnetism): esegue il cast dei raggi alle superfici del mondo e allinea l'oggetto alla superficie.</span><span class="sxs-lookup"><span data-stu-id="570c4-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="570c4-126">[`DirectionalIndicator`](#directionalindicator): Determina la posizione e l'orientamento di un oggetto come indicatore direzionale.</span><span class="sxs-lookup"><span data-stu-id="570c4-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="570c4-127">Dal punto di riferimento della destinazione SolverHandler rilevata, questo indicatore verrà orientato verso il DirectionalTarget fornito.</span><span class="sxs-lookup"><span data-stu-id="570c4-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="570c4-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applica accelerazione/velocità/attrito per simulare Momentum e Springiness per un oggetto spostato da altri resolver/componenti.</span><span class="sxs-lookup"><span data-stu-id="570c4-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="570c4-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Vincola l'oggetto a seguire le mani in un'area che non interseca GameObject con le mani.</span><span class="sxs-lookup"><span data-stu-id="570c4-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="570c4-130">Utile per contenuto interattivo vincolato a mano, ad esempio menu e così via. Il Risolutore è progettato per funzionare con [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) , ma funziona anche con [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span><span class="sxs-lookup"><span data-stu-id="570c4-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="570c4-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Deriva da HandConstraint, ma include la logica per verificare se il Palm è rivolte all'utente prima dell'attivazione.</span><span class="sxs-lookup"><span data-stu-id="570c4-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="570c4-132">Il Risolutore funziona solo con i controller [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) , con altri tipi di controller che il Risolutore si comporterà esattamente come la classe di base.</span><span class="sxs-lookup"><span data-stu-id="570c4-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="570c4-133">Per usare il sistema di Risolutore, è sufficiente aggiungere uno dei componenti elencati in precedenza a un GameObject.</span><span class="sxs-lookup"><span data-stu-id="570c4-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="570c4-134">Poiché tutti i risolutori richiedono un [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) , ne verrà creato uno automaticamente da Unity.</span><span class="sxs-lookup"><span data-stu-id="570c4-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="570c4-135">Esempi di come usare il sistema di risoluzione sono reperibili nel file **SolverExamples. scene** .</span><span class="sxs-lookup"><span data-stu-id="570c4-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="570c4-136">Come modificare il riferimento al rilevamento</span><span class="sxs-lookup"><span data-stu-id="570c4-136">How to change tracking reference</span></span>

<span data-ttu-id="570c4-137">La proprietà del *tipo di destinazione rilevata* del [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) componente definisce il punto di riferimento che tutti i resolver utilizzeranno per calcolare i relativi algoritmi.</span><span class="sxs-lookup"><span data-stu-id="570c4-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="570c4-138">Ad esempio, un tipo di valore [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) con un [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) componente semplice genererà un Raycast dalla parte iniziale e nella direzione dello sguardo dell'utente per la risoluzione della superficie da raggiungere.</span><span class="sxs-lookup"><span data-stu-id="570c4-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="570c4-139">I valori potenziali per la `TrackedTargetType` proprietà sono:</span><span class="sxs-lookup"><span data-stu-id="570c4-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="570c4-140">*Head* : il punto di riferimento è la trasformazione della fotocamera principale</span><span class="sxs-lookup"><span data-stu-id="570c4-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="570c4-141">*ControllerRay*: il punto di riferimento è la [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) trasformazione in un controller (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="570c4-142">origine puntatore in un controller di movimento o in un controller di mano) che punta alla direzione del raggio di linea</span><span class="sxs-lookup"><span data-stu-id="570c4-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="570c4-143">Utilizzare la `TrackedHandedness` proprietà per selezionare la preferenza di manualità (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="570c4-144">Left, right, both)</span><span class="sxs-lookup"><span data-stu-id="570c4-144">Left, Right, Both)</span></span>
* <span data-ttu-id="570c4-145">*HandJoint*: il punto di riferimento è la trasformazione di una giunzione a mano specifica</span><span class="sxs-lookup"><span data-stu-id="570c4-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="570c4-146">Utilizzare la `TrackedHandedness` proprietà per selezionare la preferenza di manualità (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="570c4-147">Left, right, both)</span><span class="sxs-lookup"><span data-stu-id="570c4-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="570c4-148">Utilizzare la  `TrackedHandJoint` proprietà per determinare la trasformazione congiunta da utilizzare</span><span class="sxs-lookup"><span data-stu-id="570c4-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="570c4-149">*CustomOverride*: punto di riferimento dall'oggetto assegnato `TransformOverride`</span><span class="sxs-lookup"><span data-stu-id="570c4-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="570c4-150">Per i tipi *ControllerRay* e *HandJoint* , il gestore del Risolutore tenterà di fornire prima la trasformazione a sinistra del controller o della mano, quindi il diritto se il primo non è disponibile o a meno che la `TrackedHandedness` proprietà non specifichi diversamente.</span><span class="sxs-lookup"><span data-stu-id="570c4-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="570c4-151">![Esempio di oggetto rilevato da Risolutore ](../../images/solver/TrackedObjectType-Example.gif) 
 *di varie proprietà associate a ogni TrackedTargetType*</span><span class="sxs-lookup"><span data-stu-id="570c4-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="570c4-152">La maggior parte dei resolver usa il vettore di avanzamento della destinazione della trasformazione rilevata fornita da `SolverHandler` .</span><span class="sxs-lookup"><span data-stu-id="570c4-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="570c4-153">Quando si usa un tipo di destinazione rilevata *congiuntamente* , il vettore di avanzamento del giunto della palma può puntare attraverso le dita e non attraverso il Palm.</span><span class="sxs-lookup"><span data-stu-id="570c4-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="570c4-154">Questo dipende dalla piattaforma che fornisce i dati di giunzione.</span><span class="sxs-lookup"><span data-stu-id="570c4-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="570c4-155">Per la simulazione di input e la realtà mista di Windows, è il *vettore up* che punta attraverso la Palma (ovvero</span><span class="sxs-lookup"><span data-stu-id="570c4-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="570c4-156">il vettore verde è attivo, il vettore blu è in futuro.</span><span class="sxs-lookup"><span data-stu-id="570c4-156">green vector is up, blue vector is forward).</span></span>
>
> ![Vettore di avanzamento](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="570c4-158">Per ovviare a questo problema, aggiornare la proprietà *Rotation aggiuntiva* nel `SolverHandler` **<90, 0,0>**.</span><span class="sxs-lookup"><span data-stu-id="570c4-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="570c4-159">In questo modo, il vettore di avanzamento fornito ai risolutori sta puntando attraverso la Palma e allontanandosi dall'esterno.</span><span class="sxs-lookup"><span data-stu-id="570c4-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![Rotazione aggiuntiva](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="570c4-161">In alternativa, usare il tipo di destinazione del *raggio controller* rilevato per ottenere un comportamento simile per puntare con le mani.</span><span class="sxs-lookup"><span data-stu-id="570c4-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="570c4-162">Come concatenare i risolutori</span><span class="sxs-lookup"><span data-stu-id="570c4-162">How to chain solvers</span></span>

<span data-ttu-id="570c4-163">È possibile aggiungere più `Solver` componenti allo stesso GameObject concatenando quindi gli algoritmi.</span><span class="sxs-lookup"><span data-stu-id="570c4-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="570c4-164">I `SolverHandler` componenti gestiscono l'aggiornamento di tutti i risolutori nello stesso GameObject.</span><span class="sxs-lookup"><span data-stu-id="570c4-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="570c4-165">Per impostazione predefinita, le `SolverHandler` chiamate all' `GetComponents<Solver>()` avvio restituiscono i resolver nell'ordine in cui sono visualizzate nel controllo.</span><span class="sxs-lookup"><span data-stu-id="570c4-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="570c4-166">Inoltre, impostando la proprietà di *trasformazione collegata aggiornata* su true, viene indicato che `Solver` per salvare la posizione calcolata, l'orientamento & la scalabilità in una variabile intermedia accessibile da tutti i risolutori (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="570c4-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="570c4-167">`GoalPosition`).</span></span> <span data-ttu-id="570c4-168">Se false, `Solver` aggiornerà direttamente la trasformazione del GameObject.</span><span class="sxs-lookup"><span data-stu-id="570c4-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="570c4-169">Salvando le proprietà di trasformazione in un percorso intermedio, altri risolutori sono in grado di eseguire i calcoli a partire dalla variabile intermedia.</span><span class="sxs-lookup"><span data-stu-id="570c4-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="570c4-170">In quanto Unity non consente l'aggiornamento di gameObject. Transform nello stack nello stesso frame.</span><span class="sxs-lookup"><span data-stu-id="570c4-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="570c4-171">Gli sviluppatori possono modificare l'ordine di esecuzione dei risolutori impostando `SolverHandler.Solvers` direttamente la proprietà.</span><span class="sxs-lookup"><span data-stu-id="570c4-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="570c4-172">Come creare un nuovo Risolutore</span><span class="sxs-lookup"><span data-stu-id="570c4-172">How to create a new solver</span></span>

<span data-ttu-id="570c4-173">Tutti i risolutori devono ereditare dalla classe di base astratta [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver) .</span><span class="sxs-lookup"><span data-stu-id="570c4-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="570c4-174">I requisiti principali di un'estensione del Risolutore implica l'override del `SolverUpdate` metodo.</span><span class="sxs-lookup"><span data-stu-id="570c4-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="570c4-175">In questo metodo, gli sviluppatori devono aggiornare le `GoalPosition` proprietà ereditate `GoalRotation` e `GoalScale` ai valori desiderati.</span><span class="sxs-lookup"><span data-stu-id="570c4-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="570c4-176">Inoltre, in genere è utile utilizzare `SolverHandler.TransformTarget` come frame di riferimento desiderato dal consumer.</span><span class="sxs-lookup"><span data-stu-id="570c4-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="570c4-177">Il codice riportato di seguito fornisce un esempio di un nuovo componente del Risolutore denominato `InFront` che inserisce l'oggetto collegato 2m davanti a `SolverHandler.TransformTarget` .</span><span class="sxs-lookup"><span data-stu-id="570c4-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="570c4-178">Se l'oggetto `SolverHandler.TrackedTargetType` è impostato dal consumer come [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) , `SolverHandler.TransformTarget` sarà la trasformazione della fotocamera e pertanto il Risolutore inserirà il GameObject di allegato 2m davanti allo sguardo di tutti i frame degli utenti.</span><span class="sxs-lookup"><span data-stu-id="570c4-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="570c4-179">Guide all'implementazione del Risolutore</span><span class="sxs-lookup"><span data-stu-id="570c4-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="570c4-180">Proprietà del Risolutore comune</span><span class="sxs-lookup"><span data-stu-id="570c4-180">Common solver properties</span></span>

<span data-ttu-id="570c4-181">Ogni componente del Risolutore dispone di un set di base di proprietà identiche che controllano il comportamento del Risolutore principale.</span><span class="sxs-lookup"><span data-stu-id="570c4-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="570c4-182">Se la *smussatura* è abilitata, il Risolutore aggiornerà gradualmente la trasformazione del GameObject nel tempo ai valori calcolati.</span><span class="sxs-lookup"><span data-stu-id="570c4-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="570c4-183">La velocità di questa modifica è determinata dalla proprietà *LerpTime* di ogni componente di trasformazione.</span><span class="sxs-lookup"><span data-stu-id="570c4-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="570c4-184">Ad esempio, un valore *MoveLerpTime* più elevato provocherà incrementi più lenti nello spostamento tra i frame.</span><span class="sxs-lookup"><span data-stu-id="570c4-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="570c4-185">Se *MaintainScale* è abilitato, il Risolutore utilizzerà la scala locale predefinita di GameObject.</span><span class="sxs-lookup"><span data-stu-id="570c4-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="570c4-186">![Proprietà del Risolutore principale](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="570c4-187">*Proprietà comuni ereditate da tutti i componenti del Risolutore*</span><span class="sxs-lookup"><span data-stu-id="570c4-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="570c4-188">Orbitale</span><span class="sxs-lookup"><span data-stu-id="570c4-188">Orbital</span></span>

<span data-ttu-id="570c4-189">La [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) classe è un componente lungo tag che si comporta come i pianeti in un sistema solare.</span><span class="sxs-lookup"><span data-stu-id="570c4-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="570c4-190">Il Risolutore assicurerà che il GameObject collegato orbiti attorno alla trasformazione rilevata.</span><span class="sxs-lookup"><span data-stu-id="570c4-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="570c4-191">Pertanto, se il *tipo di destinazione rilevata* di [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) è impostato su [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) , il GameObject verrà orbitato intorno all'Head dell'utente con un offset fisso applicato.</span><span class="sxs-lookup"><span data-stu-id="570c4-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="570c4-192">Gli sviluppatori possono modificare questo offset fisso per tenere i menu o altri componenti della scena a livello di occhio o di vita e così via, intorno a un utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="570c4-193">Questa operazione viene eseguita modificando le proprietà *offset locale* e *offset globale* .</span><span class="sxs-lookup"><span data-stu-id="570c4-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="570c4-194">La proprietà *tipo orientamento* determina la rotazione applicata all'oggetto se deve mantenere la rotazione originale o sempre rivolta alla fotocamera o alla superficie di qualsiasi trasformazione che sta determinando la posizione e così via.</span><span class="sxs-lookup"><span data-stu-id="570c4-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="570c4-195">![Esempio di orbita](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="570c4-196">*Esempio di orbita*</span><span class="sxs-lookup"><span data-stu-id="570c4-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="570c4-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="570c4-197">RadialView</span></span>

<span data-ttu-id="570c4-198">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView)È un altro componente di tag lungo che mantiene una parte specifica di un GameObject all'interno di tronco della visualizzazione dell'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="570c4-199">Le proprietà *Min & Max View degrees* determinano la quantità di una parte di GameObject che deve essere sempre visualizzata in visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="570c4-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="570c4-200">Le proprietà *Min & max distance* determinano il modo in cui il GameObject deve essere mantenuto dall'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="570c4-201">Ad esempio, se si cammina verso la GameObject con una *distanza minima* di 1m, il GameObject verrà spinto per assicurarsi che non sia mai più vicino a 1 milione di utenti.</span><span class="sxs-lookup"><span data-stu-id="570c4-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="570c4-202">In genere, [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) viene usato insieme al *tipo di destinazione rilevato* impostato su in [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) modo che il componente segua lo sguardo dell'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="570c4-203">Tuttavia, questo componente può funzionare per essere mantenuto in *"View"* di qualsiasi *tipo di destinazione rilevato*.</span><span class="sxs-lookup"><span data-stu-id="570c4-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="570c4-204">![Esempio di RadialView](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="570c4-205">*Esempio di RadialView*</span><span class="sxs-lookup"><span data-stu-id="570c4-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="570c4-206">Segui</span><span class="sxs-lookup"><span data-stu-id="570c4-206">Follow</span></span>

<span data-ttu-id="570c4-207">La [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) classe posiziona un elemento davanti all'oggetto della destinazione rilevata rispetto al relativo asse di avanzamento locale.</span><span class="sxs-lookup"><span data-stu-id="570c4-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="570c4-208">L'elemento può essere vincolato vagamente (noto anche come</span><span class="sxs-lookup"><span data-stu-id="570c4-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="570c4-209">Tag-Along) in modo che non venga seguito finché la destinazione rilevata non viene spostata oltre i limiti definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="570c4-210">Funziona in modo analogo al Risolutore RadialView, con controlli aggiuntivi per gestire il *numero massimo orizzontale & i gradi di visualizzazione verticali* e i meccanismi per modificare l' *orientamento* dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="570c4-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="570c4-211">![Segui proprietà](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="570c4-212">*Segui proprietà*</span><span class="sxs-lookup"><span data-stu-id="570c4-212">*Follow properties*</span></span>

<span data-ttu-id="570c4-213">![Segui la scena di esempio](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="570c4-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="570c4-214">*Seguire la scena di esempio (assets/MRTK/examples/Demos/solvers/Sceness/FollowSolverExample. Unity)*</span><span class="sxs-lookup"><span data-stu-id="570c4-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="570c4-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="570c4-215">InBetween</span></span>

<span data-ttu-id="570c4-216">La [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) classe manterrà il GameObject collegato tra due trasformazioni.</span><span class="sxs-lookup"><span data-stu-id="570c4-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="570c4-217">Questi due endpoint di trasformazione sono definiti dal [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *tipo di destinazione rilevata* di GameObject e dalla [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) seconda proprietà del *tipo di destinazione rilevata* del componente.</span><span class="sxs-lookup"><span data-stu-id="570c4-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="570c4-218">In genere, entrambi i tipi verranno impostati su [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) e i `SolverHandler.TransformOverride` valori e risultante `InBetween.SecondTransformOverride` impostati sui due endpoint rilevati.</span><span class="sxs-lookup"><span data-stu-id="570c4-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="570c4-219">In fase di esecuzione, il [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) componente creerà un altro [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) componente in base al *secondo tipo di destinazione rilevata* e alle *seconde* proprietà di sostituzione della trasformazione.</span><span class="sxs-lookup"><span data-stu-id="570c4-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="570c4-220">`PartwayOffset`Definisce la posizione lungo la linea tra due trasformazioni. l'oggetto deve essere inserito con 0,5 a metà, 1,0 alla prima trasformazione e 0,0 alla seconda trasformazione.</span><span class="sxs-lookup"><span data-stu-id="570c4-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="570c4-221">![Esempio di inbetween](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="570c4-222">*Esempio di utilizzo di inbetween Solver per la conservazione di un oggetto tra due trasformazioni*</span><span class="sxs-lookup"><span data-stu-id="570c4-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="570c4-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="570c4-223">SurfaceMagnetism</span></span>

<span data-ttu-id="570c4-224">Il [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) funziona eseguendo un Raycast su un set LayerMask di superfici e inserendo il GameObject in corrispondenza del punto di contatto.</span><span class="sxs-lookup"><span data-stu-id="570c4-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="570c4-225">L' *offset normale della superficie* GameObject la distanza del set in metri dalla superficie nella direzione della normale in corrispondenza del punto in cui si è verificata la superficie.</span><span class="sxs-lookup"><span data-stu-id="570c4-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="570c4-226">Viceversa, l'offset del *raggio della superficie* posiziona il GameObject in un set di distanza in metri di distanza dall'area, ma nella direzione opposta del Raycast eseguito.</span><span class="sxs-lookup"><span data-stu-id="570c4-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="570c4-227">Quindi, se il Raycast è lo sguardo dell'utente, il GameObject verrà spostato più a lungo sulla linea dal punto di riscontro sulla superficie della fotocamera.</span><span class="sxs-lookup"><span data-stu-id="570c4-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="570c4-228">La *modalità di orientamento* determina il tipo di rotazione da applicare in relazione al normale sulla superficie.</span><span class="sxs-lookup"><span data-stu-id="570c4-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="570c4-229">*None* : nessuna rotazione applicata</span><span class="sxs-lookup"><span data-stu-id="570c4-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="570c4-230">*TrackedTarget* : l'oggetto affronterà la trasformazione tracciata che guida il Raycast</span><span class="sxs-lookup"><span data-stu-id="570c4-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="570c4-231">*SurfaceNormal* -l'oggetto viene allineato in base al normale punto di hit sulla superficie</span><span class="sxs-lookup"><span data-stu-id="570c4-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="570c4-232">*Blended* -Object viene allineato in base al normale punto di hit sulla superficie e in base alla trasformazione rilevata.</span><span class="sxs-lookup"><span data-stu-id="570c4-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="570c4-233">Per forzare il GameObject associato a rimanere verticale in qualsiasi modalità diversa da *nessuno*, abilitare *Mantieni orientamento verticale*.</span><span class="sxs-lookup"><span data-stu-id="570c4-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="570c4-234">Usare la proprietà *Orientation Blend* per controllare il saldo tra i fattori di rotazione quando la *modalità di orientamento* è impostata su *blended*.</span><span class="sxs-lookup"><span data-stu-id="570c4-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="570c4-235">Il valore 0,0 avrà orientamento interamente guidato dalla modalità *TrackedTarget* e il valore 1,0 avrà orientamento interamente basato su *SurfaceNormal*.</span><span class="sxs-lookup"><span data-stu-id="570c4-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![Esempio di SurfaceMagnetism](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="570c4-237">Determinazione delle superfici che è possibile raggiungere</span><span class="sxs-lookup"><span data-stu-id="570c4-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="570c4-238">Quando si aggiunge un [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) componente a un GameObject, è importante considerare il livello di GameObject e dei relativi elementi figlio, se presenti.</span><span class="sxs-lookup"><span data-stu-id="570c4-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="570c4-239">Il componente funziona eseguendo vari tipi di raycasts per determinare la superficie a cui "magnete".</span><span class="sxs-lookup"><span data-stu-id="570c4-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="570c4-240">Se il GameObject del Risolutore dispone di un Collider su uno dei livelli elencati nella `MagneticSurfaces` proprietà di `SurfaceMagnetism` , il Raycast probabilmente si raggiungerà a sua volta causando la connessione del GameObject al punto di Collider.</span><span class="sxs-lookup"><span data-stu-id="570c4-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="570c4-241">Questo comportamento dispari può essere evitato impostando il GameObject principale e tutti gli elementi figlio sul livello *Ignora Raycast* o modificando in `MagneticSurfaces` modo appropriato la matrice LayerMask.</span><span class="sxs-lookup"><span data-stu-id="570c4-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="570c4-242">Viceversa, un [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject non entrerà in conflitto con le superfici su un livello non elencato nella `MagneticSurfaces` Proprietà.</span><span class="sxs-lookup"><span data-stu-id="570c4-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="570c4-243">È in genere consigliabile posizionare tutte le superfici desiderate su un livello dedicato (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="570c4-244">*Superfici*) e impostando la `MagneticSurfaces` proprietà solo su questo livello.</span><span class="sxs-lookup"><span data-stu-id="570c4-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="570c4-245">Per *impostazione predefinita* , è possibile che i componenti dell'interfaccia *utente o i* cursori contribuiscano al Risolutore.</span><span class="sxs-lookup"><span data-stu-id="570c4-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="570c4-246">Infine, le superfici più lontane dell' `MaxRaycastDistance` impostazione della proprietà verranno ignorate da `SurfaceMagnetism` raycasts.</span><span class="sxs-lookup"><span data-stu-id="570c4-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="570c4-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="570c4-247">DirectionalIndicator</span></span>

<span data-ttu-id="570c4-248">La [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) classe è un componente lungo tag che si orienta alla direzione di un punto desiderato nello spazio.</span><span class="sxs-lookup"><span data-stu-id="570c4-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="570c4-249">Utilizzato più di frequente quando il *tipo di destinazione rilevato* di [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) è impostato su [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) .</span><span class="sxs-lookup"><span data-stu-id="570c4-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="570c4-250">In questo modo, un componente UX con il [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  Risolutore consentirà all'utente di esaminare il punto desiderato nello spazio.</span><span class="sxs-lookup"><span data-stu-id="570c4-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="570c4-251">Il punto desiderato nello spazio viene determinato tramite la proprietà di *destinazione direzionale* .</span><span class="sxs-lookup"><span data-stu-id="570c4-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="570c4-252">Se la destinazione direzionale è visualizzabile dall'utente o qualsiasi frame di riferimento è impostato in, il [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) Risolutore Disabilita tutti i [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) componenti sottostanti.</span><span class="sxs-lookup"><span data-stu-id="570c4-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="570c4-253">Se non visualizzabile, tutto verrà abilitato sull'indicatore.</span><span class="sxs-lookup"><span data-stu-id="570c4-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="570c4-254">La dimensione dell'indicatore ridurrà più vicino l'utente a acquisire la *destinazione direzionale* nel relativo FOV.</span><span class="sxs-lookup"><span data-stu-id="570c4-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="570c4-255">*Scala indicatore min* : scala minima per l'oggetto indicatore</span><span class="sxs-lookup"><span data-stu-id="570c4-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="570c4-256">*Scala indicatore max* : scala massima per l'oggetto indicatore</span><span class="sxs-lookup"><span data-stu-id="570c4-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="570c4-257">*Fattore di scala visibilità* -moltiplicatore per aumentare o diminuire il FOV che determina se il punto di *destinazione direzionale* è visualizzabile o meno</span><span class="sxs-lookup"><span data-stu-id="570c4-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="570c4-258">*Offset visualizzazione* : dal punto di vista del frame di riferimento (ad esempio</span><span class="sxs-lookup"><span data-stu-id="570c4-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="570c4-259">fotocamera possibilmente), questa proprietà definisce la distanza nella direzione dell'indicatore nell'oggetto dal centro del viewport.</span><span class="sxs-lookup"><span data-stu-id="570c4-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="570c4-260">![Proprietà indicatore direzionale](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="570c4-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="570c4-261">*Proprietà indicatore direzionale*</span><span class="sxs-lookup"><span data-stu-id="570c4-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="570c4-262">![Scena di esempio indicatore direzionale](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="570c4-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="570c4-263">*Scenario di esempio dell'indicatore direzionale (assets/MRTK/examples/Demos/solvers/Sceness/DirectionalIndicatorSolverExample. Unity)*</span><span class="sxs-lookup"><span data-stu-id="570c4-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="570c4-264">Menu a mano con HandConstraint e HandConstraintPalmUp</span><span class="sxs-lookup"><span data-stu-id="570c4-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![Esempio di UX menu a mano](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="570c4-266">Il [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) comportamento fornisce un risolutore che vincola l'oggetto rilevato a un'area sicura per il contenuto vincolato della mano, ad esempio l'interfaccia utente, i menu e così via.</span><span class="sxs-lookup"><span data-stu-id="570c4-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="570c4-267">Le aree sicure sono considerate aree che non si intersecano con la mano.</span><span class="sxs-lookup"><span data-stu-id="570c4-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="570c4-268">Viene inoltre inclusa una classe derivata di [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) chiamata [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) per illustrare un comportamento comune di attivazione dell'oggetto rilevato del Risolutore quando il Palm è rivolte all'utente.</span><span class="sxs-lookup"><span data-stu-id="570c4-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="570c4-269">Per esempi relativi all'uso del Risolutore di vincoli di mano, [vedere la pagina del menu](../hand-menu.md) a mano per creare menu a mano.</span><span class="sxs-lookup"><span data-stu-id="570c4-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="570c4-270">Vedi anche</span><span class="sxs-lookup"><span data-stu-id="570c4-270">See also</span></span>

* [<span data-ttu-id="570c4-271">Rilevamento della mano</span><span class="sxs-lookup"><span data-stu-id="570c4-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="570c4-272">Sguardo fisso</span><span class="sxs-lookup"><span data-stu-id="570c4-272">Gaze</span></span>](../../input/gaze.md)
